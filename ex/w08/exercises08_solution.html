<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>exercises08_solution – CSC477 - Fall 2024</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-3610b36fc08898c07d6e0ffcd4000319.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-69b08db278f499bc7d235ce342f73d67.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-3610b36fc08898c07d6e0ffcd4000319.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta property="og:title" content="CSC477 - Fall 2024">
<meta property="og:description" content="Homepage for CSC477/CSC2630: Introduction to Mobile Robotics, Fall 2024">
<meta property="og:image" content="https://csc477.github.io/website_fall24/ex/w08/rnn-addition.png">
<meta property="og:site_name" content="CSC477 - Fall 2024">
<meta name="twitter:title" content="CSC477 - Fall 2024">
<meta name="twitter:description" content="Homepage for CSC477/CSC2630: Introduction to Mobile Robotics, Fall 2024">
<meta name="twitter:image" content="https://csc477.github.io/website_fall24/ex/w08/rnn-addition.png">
<meta name="twitter:card" content="summary">
</head><body class="quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>\usepackage{../latex_packages/abbreviations}
\usepackage{fancyhdr}
\pagestyle{fancy}
\let\headrule\empty
\let\footrule\empty
\lhead{{\bfseries CSC\,413}}
\chead{{\bfseries Exercises - Week 8}}
\rhead{{\bfseries Shkurti / Gilitschenski}}
\lfoot{{}}
\cfoot{{\thepage}}
\rfoot{{}}

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>





<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#exercise-1---rnn-for-sentiment-analysis" id="toc-exercise-1---rnn-for-sentiment-analysis" class="nav-link active" data-scroll-target="#exercise-1---rnn-for-sentiment-analysis">Exercise 1 - RNN for Sentiment Analysis</a>
  <ul class="collapse">
  <li><a href="#solution" id="toc-solution" class="nav-link" data-scroll-target="#solution">Solution</a></li>
  </ul></li>
  <li><a href="#exercise-2---scalar-rnn" id="toc-exercise-2---scalar-rnn" class="nav-link" data-scroll-target="#exercise-2---scalar-rnn">Exercise 2 - Scalar RNN</a>
  <ul class="collapse">
  <li><a href="#solution-1" id="toc-solution-1" class="nav-link" data-scroll-target="#solution-1">Solution</a></li>
  </ul></li>
  <li><a href="#exercise-3---rnn-addition" id="toc-exercise-3---rnn-addition" class="nav-link" data-scroll-target="#exercise-3---rnn-addition">Exercise 3 - RNN Addition</a>
  <ul class="collapse">
  <li><a href="#solution-2" id="toc-solution-2" class="nav-link" data-scroll-target="#solution-2">Solution</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/csc477/website_fall24/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>





<section id="exercise-1---rnn-for-sentiment-analysis" class="level2">
<h2 class="anchored" data-anchor-id="exercise-1---rnn-for-sentiment-analysis">Exercise 1 - RNN for Sentiment Analysis</h2>
<!-- Based on Week8 Practice exercises -->
<p>Suppose we are training a vanilla RNN like below to determine whether a sentence expresses positive or negative sentiment. This RNN will be a character-level RNN where <span class="math inline">\(x^{(1)}, \ldots, x^{(T)}\)</span> is the sequence of input characters. The RNN is given as follows: <span class="math display">\[\begin{align*}
h^{(t)} &amp;= \tanh\li(U x^{(t)} + W h^{(t-1)} + b\ri) \\
y &amp;= \sigma\li(V h^{(T)} + d\ri)
\end{align*}\]</span></p>
<ol type="a">
<li><p>How many times do we need to apply the weight matrix <span class="math inline">\(U\)</span>, <span class="math inline">\(W\)</span>, and <span class="math inline">\(V\)</span>?</p></li>
<li><p>What are the shapes of the matrices <span class="math inline">\(U\)</span>, <span class="math inline">\(W\)</span>, and <span class="math inline">\(V\)</span>?</p></li>
<li><p>How many addition and multiplication operations are required to make a prediction? You can assume that no addition and multiplications are performed when applying the tanh and sigmoid activation functions.</p></li>
</ol>
<section id="solution" class="level3">
<h3 class="anchored" data-anchor-id="solution">Solution</h3>
<ol type="a">
<li><p>We will need to compute <span class="math inline">\(h^{(t)}\)</span> for <span class="math inline">\(t = 1, \ldots, T\)</span>. Each of this computation requires applying the weight matrices <span class="math inline">\(W\)</span> and <span class="math inline">\(T\)</span> once. The matrix <span class="math inline">\(V\)</span> is only applied once at the end. Therefore, we need to apply <span class="math inline">\(W\)</span> and <span class="math inline">\(U\)</span> <span class="math inline">\(T\)</span> times each and <span class="math inline">\(V\)</span> once.</p></li>
<li><p>The shape of <span class="math inline">\(U\)</span> is <span class="math inline">\(d_h \times d_x\)</span>, the shape of <span class="math inline">\(W\)</span> is <span class="math inline">\(d_h \times d_h\)</span>, and the shape of <span class="math inline">\(V\)</span> is <span class="math inline">\(d_y \times d_h\)</span>, where <span class="math inline">\(d_h\)</span> is the dimensionality of the <span class="math inline">\(h^{(i)}\)</span> (i.e.&nbsp;<span class="math inline">\(h^{(i)}\in\R^{d_h}\)</span>), <span class="math inline">\(d_x\)</span> is the dimensionality of the inputs <span class="math inline">\(x^{(i)}\)</span>, and <span class="math inline">\(d_y\)</span> is the dimensionality of the ouput <span class="math inline">\(y\)</span>.</p></li>
<li><p>For each of the <span class="math inline">\(T\)</span> steps, we need to perform two matrix-vector multiplications (one for <span class="math inline">\(Ux^{(i)}\)</span> and one for <span class="math inline">\(Uh^{(i)}\)</span>) and two vector additions. To compute the output, we need one additional matrix-vector multiplication and one vector addition.</p></li>
</ol>
</section>
</section>
<section id="exercise-2---scalar-rnn" class="level2">
<h2 class="anchored" data-anchor-id="exercise-2---scalar-rnn">Exercise 2 - Scalar RNN</h2>
<!-- from Week8 Practice exercises -->
<p>Suppose we have the following vanilla RNN network, where the inputs and hidden units are scalars. <span class="math display">\[\begin{align*}
h^{(t)} &amp;= \tanh\li(w \cdot h^{(t-1)} + u \cdot x^{(t-1)} + b_h\ri) \\
y &amp;= \sigma\li(v \cdot h^{(T)} + b_y\ri)
\end{align*}\]</span></p>
<ol type="a">
<li><p>Show that if <span class="math inline">\(|w| &lt; 1\)</span>, and the number of time steps <span class="math inline">\(T\)</span> is large, then the gradient <span class="math inline">\(\frac{\partial y}{\partial x^{(0)}}\)</span> vanishes.</p></li>
<li><p>Why is the result from Part (a) troubling?</p></li>
</ol>
<section id="solution-1" class="level3">
<h3 class="anchored" data-anchor-id="solution-1">Solution</h3>
<ol type="a">
<li><p>To make the sequence length <span class="math inline">\(T\)</span> explicit in the notation, we will write <span class="math inline">\(y\)</span> instead of <span class="math inline">\(y_T\)</span>. Formally, what we have to show is <span class="math display">\[
|w|&lt;1 \implies \lim_{T\to\infty} \fr{\partial y_T}{\partial x^{(0)}} = 0 .
\]</span> For the proof, we expand the derivative of <span class="math inline">\(y_T\)</span> with respect to <span class="math inline">\(x^{(0)}\)</span> using the chain rule: <span class="math display">\[
\begin{aligned}
\fr{\partial y_T}{\partial x^{(0)}}
  &amp; = \si'\li(v \cdot h^{(T)} + b_y\ri)
    \cdot v \cdot \fr{\partial h^{(T)}}{\partial x^{(0)}} \\
  &amp; =
  \si'\li(v \cdot h^{(T)} + b_y\ri)
    \cdot v
    \cdot
      \underbrace{
        \tanh'\li(w \cdot h^{(T-1)} + u \cdot x^{(T-1)} + b_h\ri)
      }_{A_{T-1}(x^{(0)})}
    \cdot w \cdot \fr{\partial h^{(T-1)}}{\partial x^{(0)}} \\
&amp; = \ldots \\
&amp; = \si'\li(v \cdot h^{(T)} + b_y\ri)
    \cdot v
    \cdot \prod_{t=2}^{T-1} A_{t}(x^{(0)})
    \cdot w^{T-1} \cdot \fr{\partial h^{(1)}}{\partial x^{(0)}} .\\
\end{aligned}
\]</span> Using this, we can analyze the absolute value of the derivative <span class="math inline">\(\partial y_T/\partial x^{(0)}\)</span>. For <span class="math inline">\(\tanh\)</span> and <span class="math inline">\(\si\)</span>, the absolute value of their respective derivatives is bounded by <span class="math inline">\(1\)</span>. Thus, we have <span class="math display">\[
\begin{aligned}
\li|\fr{\partial y_T}{\partial x^{(0)}} \ri|
&amp; =
\underbrace{
  \li|\si'\li(v \cdot h^{(T)} + b_y\ri) \ri|
}_{\leq 1}
\cdot |v|
\cdot \prod_{t=2}^{T-1}
  \underbrace{\li| A_{t}(x^{(0)}) \ri|}_{\leq 1}
\cdot \li|w^{T-1}\ri|
\cdot \li|\fr{\partial h^{(1)}}{\partial x^{(0)}}\ri| \\
&amp; \leq |v|
\cdot \li|w^{T-1}\ri|
\cdot \li|\fr{\partial h^{(1)}}{\partial x^{(0)}}\ri| \\
\end{aligned}
\]</span> Because <span class="math inline">\(|w|&lt;1\)</span>, this converges to <span class="math inline">\(0\)</span> as <span class="math inline">\(T\to\infty\)</span> and thus <span class="math inline">\(|\partial y_T/\partial x^{(0)}|\)</span> also converges to <span class="math inline">\(0\)</span>, i.e.&nbsp;the gradient vanishes.</p></li>
<li><p>It implies that in the considered setting, the input has no impact on the output.</p></li>
</ol>
</section>
</section>
<section id="exercise-3---rnn-addition" class="level2">
<h2 class="anchored" data-anchor-id="exercise-3---rnn-addition">Exercise 3 - RNN Addition</h2>
<!-- From Tutorial 9 of past offering -->
<p>In this problem, you will implement a recurrent neural network which implements binary addition. The inputs are given as binary sequences, starting with the significant binary digit. (It is easier to start from the least significant bit, just like how you did addition in grade school.) The sequences will be padded with at least one zero as the most significant digit, so that the output length is the same as the input length. For example, the problem <span class="math inline">\(100111 + 110010\)</span>, whose target output value is <span class="math inline">\(1011001\)</span>, will be represented as follows: <span class="math display">\[\begin{align*}
\bf{x}^{(1)} = \begin{bmatrix}1 \\ 0\end{bmatrix},
\bf{x}^{(2)} = \begin{bmatrix}1 \\ 1\end{bmatrix},
\bf{x}^{(3)} = \begin{bmatrix}1 \\ 0\end{bmatrix},
\bf{x}^{(4)} = \begin{bmatrix}0 \\ 0\end{bmatrix},
\bf{x}^{(5)} = \begin{bmatrix}0 \\ 1\end{bmatrix},
\bf{x}^{(6)} = \begin{bmatrix}1 \\ 1\end{bmatrix},
\bf{x}^{(7)} = \begin{bmatrix}0 \\ 0\end{bmatrix}
\end{align*}\]</span></p>
<p>With the target output: <span class="math display">\[\begin{align*}
y^{(1)} = 1,
y^{(2)} = 0,
y^{(3)} = 0,
y^{(4)} = 1,
y^{(5)} = 1,
y^{(6)} = 0,
y^{(7)} = 1,
\end{align*}\]</span></p>
<p>There are two input units corresponding to the two inputs, and one output unit. Therefore, the pattern of inputs and outputs for this example would be:</p>
<p><img src="rnn-addition.png" class="img-fluid" style="width:3in"></p>
<p>Design, by hand, the weights and biases for an RNN which has two input units, three hidden units, and one output unit, which implements binary addition as discussed above. All of the units use the hard threshold activation function (<span class="math inline">\(f(x) = 1\)</span> if <span class="math inline">\(x &gt; 0\)</span> and <span class="math inline">\(0\)</span> otherwise). In particular, specify weight matrices <span class="math inline">\(\mathbf{U}\)</span>, <span class="math inline">\(\mathbf{v}\)</span>, and <span class="math inline">\(\mathbf{W}\)</span>, bias vector <span class="math inline">\(\mathbf{b}_{\mathbf{h}}\)</span>, and scalar bias <span class="math inline">\(b_y\)</span> for the following architecture: <span class="math display">\[\begin{align*}
h^{(t)} &amp;= f(\bf{W}h^{(t-1)} + \bf{U}\bf{x}^{(t)} + \bf{b_h}) \\
y^{(t)} &amp;= f(\bf{v}^T h^{(t)} + b_y)
\end{align*}\]</span></p>
<ol type="a">
<li><p>What are the shapes of <span class="math inline">\(\mathbf{U}\)</span>, <span class="math inline">\(\mathbf{v}\)</span>, <span class="math inline">\(\mathbf{W}\)</span>, and <span class="math inline">\(\mathbf{b}_{\mathbf{h}}\)</span>?</p></li>
<li><p>Come up with values for <span class="math inline">\(\mathbf{U}\)</span>, <span class="math inline">\(\mathbf{W}\)</span>, and <span class="math inline">\(\mathbf{b}_{\mathbf{h}}\)</span>. Justify your answer. <strong>Hint:</strong> When performing binary addition, in addition to adding up two digits in a column, we need to track whether there is a digit from the previous column. We will choose one of the three units in <span class="math inline">\(\bf{h}^{(t)}\)</span>, say <span class="math inline">\(\bf{h}_2^{(t)}\)</span>, to represent this carry digit. You may also find it helpful to set <span class="math inline">\(\bf{h}_1\)</span> to activate if the sum of the 3 digits is at least 1, <span class="math inline">\(\bf{h}_2\)</span> to activate if the sum is at least 2, and <span class="math inline">\(\bf{h}_3\)</span> to activate if the sum is at least 3.</p></li>
<li><p>Come up with the values of <span class="math inline">\(\bf{v}\)</span> and <span class="math inline">\(b_y\)</span>. Justify your answer.</p></li>
</ol>
<section id="solution-2" class="level3">
<h3 class="anchored" data-anchor-id="solution-2">Solution</h3>
<ol type="a">
<li><p>Since the inputs <span class="math inline">\(\bf{x}^{(t)}\)</span> are <span class="math inline">\(2 \times 1\)</span> and the hidden units <span class="math inline">\(\bf{h}^{(t)}\)</span> are <span class="math inline">\(2 \times 1\)</span>, we should have:</p>
<ul>
<li><span class="math inline">\(\bf{W}\)</span> is <span class="math inline">\(3 \times 3\)</span></li>
<li><span class="math inline">\(\bf{U}\)</span> is <span class="math inline">\(3 \times 2\)</span></li>
<li><span class="math inline">\(\bf{b}_h\)</span> is <span class="math inline">\(3 \times 1\)</span></li>
<li><span class="math inline">\(\bf{v}\)</span> is <span class="math inline">\(3 \times 1\)</span></li>
</ul></li>
<li><p>We will follow the hint and implement the addition in our RNN such that:</p>
<ol type="1">
<li>The first of our hidden units <span class="math inline">\(h_1^{(t)}\)</span> is 1 if and only if the sum <span class="math inline">\(S^{(t)} \doteq x_1^{(t)} + x_2^{(t)} + c^{(t-1)} \geq 1\)</span>, where by <span class="math inline">\(c^{(t-1)}\)</span> we denote a carry (<span class="math inline">\(\bf{h_2}^{(t-1)}\)</span> from the previous addition). Note, these <span class="math inline">\(S^{(t)}\)</span> and <span class="math inline">\(c^{(t-1)}\)</span> are not variables of the model, merely our notation to help us to work out the solution.</li>
<li>The <span class="math inline">\(h_2^{(t)}\)</span> is 1 iff the sum <span class="math inline">\(S^{(t)} \geq 2\)</span>,</li>
<li>and <span class="math inline">\(h_3^{(t)}\)</span> is 1 iff the sum <span class="math inline">\(S^{(t)}\)</span> is 3.</li>
</ol>
<p>Notice that the carry <span class="math inline">\(c^{(t-1)}\)</span> is going to be 1 iff <span class="math inline">\(h_2^{(t-1)}=1\)</span> and 0 otherwise, i.e.&nbsp;when the previous addition was 2 or 3. Therefore to compute <span class="math inline">\(h_i^{(t)}\)</span> we need to first compute the sum <span class="math inline">\(S^{(t)} = x_1^{(t)} + x_2^{(t)} + h_2^{(t-1)}\)</span> and then offset it by <span class="math inline">\(-i+1\)</span> so that after applying the hard threshold function we get the desired value as specified above. This can be achieved with the following set of parameters: <span class="math display">\[
\mathbf{U}= \begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 1 \\
    1 &amp; 1 \end{bmatrix},\quad
\mathbf{W}=\begin{bmatrix}
    0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0\end{bmatrix},\quad
\mathbf{b_h}= \begin{bmatrix}
    -0.5 \\
    -1.5 \\
    -2.5 \end{bmatrix}.
\]</span></p></li>
<li><p>To compute the output <span class="math inline">\(y^{(t)}\)</span> we need to check if the <span class="math inline">\(S^{(t)}\)</span> is 1 or 3, that is, if either <span class="math inline">\(h_1^{(t)} = 1\)</span> while all other hidden units are zero or all hidden units are 1. We can accomplish this by setting: <span class="math inline">\(\mathbf{v}=\begin{bmatrix} 1, -1, 1 \end{bmatrix}\)</span> and <span class="math inline">\(b_y = -0.5\)</span>.</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/csc477\.github\.io\/website_fall24");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Florian Shkurti</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/csc477/website_fall24/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This page is built with ❤️, <a href="https://quarto.org/">Quarto</a> and inspiration from <a href="https://sta210-s22.github.io/website/">STA210</a>.</p>
</div>
  </div>
</footer>




</body></html>