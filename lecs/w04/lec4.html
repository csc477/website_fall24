<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lec4 – CSC477 - Fall 2024</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-3610b36fc08898c07d6e0ffcd4000319.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-69b08db278f499bc7d235ce342f73d67.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-3610b36fc08898c07d6e0ffcd4000319.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="CSC477 - Fall 2024">
<meta property="og:description" content="Homepage for CSC477/CSC2630: Introduction to Mobile Robotics, Fall 2024">
<meta property="og:site_name" content="CSC477 - Fall 2024">
<meta name="twitter:title" content="CSC477 - Fall 2024">
<meta name="twitter:description" content="Homepage for CSC477/CSC2630: Introduction to Mobile Robotics, Fall 2024">
<meta name="twitter:card" content="summary">
</head>

<body class="quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>





<p>CSC477 Introduction to Mobile Robotics</p>
<p>Florian Shkurti</p>
<p>Week #5: Discrete Planning in Known Environments</p>
<p>Today’s agenda</p>
<p>• Dijkstra’s Planning Algorithm • A* Planning Algorithm • Sampling Based Planners</p>
<p>• Rapidly-exploring Random Trees (RRT) • Probabilistic Roadmaps (PRM)</p>
<p>Planning</p>
<p>• So far we have been trying to compute state-dependent feedback</p>
<p>controllers u(x)=Kx</p>
<p>Planning</p>
<p>• So far we have been trying to compute state-dependent feedback</p>
<p>controllers u(x)=Kx</p>
<p>• A plan is usually “open-loop,” in the sense that it is assumed that</p>
<p>once computed you can execute it perfectly</p>
<p>• This is not realistic because: wind, drag, external forces, friction,</p>
<p>unknown factors make the system diverge from the planned trajectory.</p>
<p>Planning</p>
<p>• So far we have been trying to compute state-dependent feedback controllers</p>
<p>u(x)=Kx</p>
<p>• A plan is usually “open-loop,” in the sense that it is assumed that once computed</p>
<p>you can execute it perfectly</p>
<p>• This is not realistic because: wind, drag, external forces, friction, unknown factors</p>
<p>make the system diverge from the planned trajectory.</p>
<p>• Planning does not usually take external disturbances into account.</p>
<p>(External, independent feedback controllers have to make sure the robot is following the path closely)</p>
<p>Why Bother Planning?</p>
<p>Sense-Plan-Act Paradigm: Planning Is Necessary</p>
<p>Sense</p>
<p>State and Map Estimation</p>
<p>Plan</p>
<p>Act</p>
<p>Sense-Plan-Act Paradigm: Planning Is Necessary</p>
<p>Subsumption Architecture: Planning Is Not Necessary</p>
<p>Subsumption Architecture: Planning Is Not Necessary</p>
<p>He means: why bother estimating state and planning? It’s too much work and could be error-prone. Why not only have a hierarchy of reactive behaviors/controllers?</p>
<p>One possibility: instead of u(state)=… use u(sensory observation)=…</p>
<p>Subsumption Architecture: Planning Is Not Necessary</p>
<p>Planning as graph search</p>
<p>• Graph nodes represent discrete states • Edges represent transitions/actions • Edges have weights</p>
<p>• Potential queries:</p>
<p>• Shortest path from node a to node b, that does not hit obstacles • Is b reachable from a?</p>
<p>Planning as graph search</p>
<p>• Graph nodes represent discrete states • Edges represent transitions/actions • Edges have weights</p>
<p>• Potential queries:</p>
<p>• Shortest path from node a to node b, that does not hit obstacles • Is b reachable from a?</p>
<p>• Typical assumptions:</p>
<p>• Current state is known • Map is known • Map is mostly static</p>
<p>Dynamic Programming</p>
<p>Cost-to-go to destination starting from node v</p>
<p>Instantaneous transition cost needs to be non-negative</p>
<p>Dynamic Programming</p>
<p>Cost-to-go to destination starting from node v</p>
<p>Base case</p>
<p>Instantaneous transition cost needs to be non-negative</p>
<p>Neighbors of v. i.e.&nbsp;available actions</p>
<p>Note: this should remind you of the LQR cost-to-go update</p>
<p>Dynamic Programming</p>
<p>Worst-Case Complexity:</p>
<p>In 2D grid world</p>
<p>Cost-to-go to destination node starting from node v. Could also have denoted it</p>
<p>Base case</p>
<p>Instantaneous transition cost for adjacent nodes needs to be non-negative</p>
<p>Dijkstra’s algorithm: example runs</p>
<p>Dijkstra’s algorithm</p>
<p>• Let denote the length of the optimal path from the source node to node (i.e.&nbsp;cost-to-come, not cost-to-go like before)</p>
<p>• Set for all nodes except the source: • Add all nodes to priority queue Q with cost-to-come as priority • While Q is not empty:</p>
<p>Dijkstra’s algorithm</p>
<p>• Let denote the length of the optimal path from the source node</p>
<p>to node (i.e.&nbsp;cost-to-come, not cost-to-go like before)</p>
<p>• Set for all nodes except the source: • Add all nodes to priority queue Q with cost-to-come as priority • While Q is not empty:</p>
<p>• Extract the node with minimum cost-to-come from the queue Q • If found goal then done • Remove from the queue</p>
<p>The cost-to-come of is final at this point. Need to check if we can reduce the cost-to-come of its neighbors.</p>
<p>Dijkstra’s algorithm</p>
<p>• Let denote the length of the optimal path from the source node</p>
<p>to node (i.e.&nbsp;cost-to-come, not cost-to-go like before)</p>
<p>• Set for all nodes except the source: • Add all nodes to priority queue Q with cost-to-come as priority • While Q is not empty:</p>
<p>• Extract the node with minimum cost-to-come from the queue Q • If found goal then done • Remove from the queue</p>
<p>The cost-to-come of is final at this point. Need to check if we can reduce the cost-to-come of its neighbors.</p>
<p>• For in neighborhood of :</p>
<p>• If then</p>
<p>• Update priority of in Q to be</p>
<p>Dijkstra’s algorithm</p>
<p>• Let denote the length of the optimal path from the source node</p>
<p>to node (i.e.&nbsp;cost-to-come, not cost-to-go like before)</p>
<p>• Set for all nodes except the source: • Add all nodes to priority queue Q with cost-to-come as priority • While Q is not empty:</p>
<p>• Extract the node with minimum cost-to-come from the queue Q • If found goal then done • Remove from the queue</p>
<p>The cost-to-come of is final at this point. Need to check if we can reduce the cost-to-come of its neighbors.</p>
<p>• For in neighborhood of :</p>
<p>• If then</p>
<p>• Update priority of in Q to be</p>
<p>For Fibonacci heaps</p>
<p>Dijkstra’s algorithm: example runs</p>
<p>Many nodes are explored unnecessarily. We are sure that they are not going to be part of the solution.</p>
<p>A* Search: Main Idea</p>
<p>• Modifies Dijkstra’s algorithm to be more efficient • Expands fewer nodes than Dijkstra’s by using a heuristic</p>
<p>• While Dijkstra prioritizes nodes based on cost-to-come • A* prioritizes them based on:</p>
<p>cost-to-come to + lower bound on cost-to-go from to</p>
<p>Lower bound on cost of path from source to destination that passes through</p>
<p>Optimistic search: explore node with smallest f(v) next</p>
<p>A* Search: Main Idea</p>
<p>• Modifies Dijkstra’s algorithm to be more efficient • Expands fewer nodes than Dijkstra’s by using a heuristic</p>
<p>• While Dijkstra prioritizes nodes based on cost-to-come • A* prioritizes them based on:</p>
<p>cost-to-come to + lower bound on cost-to-go from to</p>
<p>Lower bound on cost of path from source to destination that passes through</p>
<p>h() is called a heuristic. h() must be admissible, i.e.&nbsp;underestimate the cost-to-go from v to destination. h() must also be monotonic, i.e.&nbsp;satisfy the triangle inequality.</p>
<p>A* Search</p>
<p>• Set for all nodes except the source: • Set for all nodes except the source: • Add to priority queue Q with priority • While Q is not empty:</p>
<p>• Extract the node with minimum from the queue Q • If found goal then done. Follow the parent pointers from to get the path. • Remove from the queue Q • explored( ) = true • For in neighborhood of if not explored( ):</p>
<p>•</p>
<p>If not in Q then</p>
<p>• Add u in Q with cost-to-come and priority • Set the parent of to be</p>
<p>• Else if</p>
<p>• Update the cost-to-come and the priority of in Q • Set the parent of to be</p>
<p>Dijkstra vs A*</p>
<p>A* for cars</p>
<p>Configuration Space</p>
<p>Idea: dilate obstacles to account for the ways the robot can collide with them.</p>
<p>Why? Instead of planning in the work space and checking whether the robot’s body collides with obstacles, plan in configuration space where you can treat the robot as a point because the obstacles are dilated.</p>
<p>This idea is typically not used for robots with high-dimensional states.</p>
<p>Configuration Space</p>
<p>How do we dilate obstacles?</p>
<p>Minkowski Sum</p>
<p>Robot</p>
<p>Drawbacks of grid-based planners</p>
<p>• Grid-based planning works well for grids of up to 3-4 dimensions</p>
<p>• State-space discretization suffers from combinatorial explosion:</p>
<p>• If the state is and we split each dimension into N</p>
<p>bins then we will have nodes in the graph.</p>
<p>• This is not practical for planning paths for robot arms with multiple</p>
<p>joints, or other high-dimensional systems.</p>
<p>Sampling the state-space</p>
<p>• Need to find ways to reduce the continuous domain into a sparse</p>
<p>representation: graphs, trees etc.</p>
<p>• Today: • Rapidly-exploring Random Tree (RRT), • Probabilistic RoadMap (PRM) • Visibility Planning • Smoothing Planned Paths</p>
<p>RRT</p>
<p>Main idea: maintain a tree of reachable configurations from the root Main steps:</p>
<p>• Sample random state • Find the closest state (node) already in the tree • Steer the closest node towards the random state</p>
<p>RRT</p>
<p>RRT</p>
<p>Things to pay attention to:</p>
<p>SampleFree() needs to sample a random state from the uniform distribution. How do you sample rotations uniformly?</p>
<p>RRT</p>
<p>Things to pay attention to:</p>
<p>Nearest() searches for the nearest neighbor of a given vector. Brute force search examines |V| nodes (increasing). Is there a more efficient method?</p>
<p>RRT</p>
<p>Things to pay attention to:</p>
<p>Steer() finds the controls that take the nearest state to the new state. Easy for omnidirectional robots. What about non-holonomic systems?</p>
<p>RRT</p>
<p>Things to pay attention to:</p>
<p>ObstacleFree() checks the path from the nearest state to the new state for collisions. How do you do collision checks?</p>
<p>RRT</p>
<p>Things to pay attention to:</p>
<p>Upside of using ObstacleFree(): you don’t need to model obstacles in Steer(). For example, if Steer() computes LQR controllers you don’t need to model obstacles in the control computation.</p>
<p>RRT: uniform sampling</p>
<p>• Only tricky case is when the state contains rotation components • For example: • State involving both rotation and translation components is often</p>
<p>called the pose of the system.</p>
<p>• Idea #1: Uniformly sample 3 Euler angles (roll, pitch, yaw)</p>
<p>3D rotation visualization: rotation axis is a point on a sphere, rotation angle is the direction of the red arrow</p>
<p>Idea #1 Not uniform after all</p>
<p>Correct, uniform</p>
<p>RRT: uniform sampling</p>
<p>• Only tricky case is when the state contains rotation components • For example: • State involving both rotation and translation components is often</p>
<p>called the pose of the system.</p>
<p>• Idea #1: Uniformly sample 3 Euler angles (roll, pitch, yaw)</p>
<p>Nonuniformity at the north pole caused by Gimbal Lock: same rotation parameterized by different Euler angles</p>
<p>Idea #1 Not uniform after all</p>
<p>Correct, uniform</p>
<p>RRT: uniform sampling</p>
<p>• Idea #2: Uniformly sample a quaternion • First, uniformly sample • Then output the unit quaternion</p>
<p>• Idea #3: Uniformly sample rotation matrices. • It’s possible but we won’t discuss it here.</p>
<p>RRT: finding the nearest neighbor</p>
<p>• Any alternatives to linear (brute force) search?</p>
<p>RRT: finding the nearest neighbor</p>
<p>• Any alternatives to linear (brute force) search? • Idea #1: space partitioning, e.g.&nbsp;kd-trees</p>
<p>Balanced kd-tree: Can query in O(logn)</p>
<p>Each split is done along the median of the points on that region</p>
<p>RRT: finding the nearest neighbor</p>
<p>• Any alternatives to linear (brute force) search? • Idea #1: space partitioning, e.g.&nbsp;kd-trees • Idea #2: locality-sensitive hashing</p>
<p>• Maintains buckets • Similar points are placed on the same bucket • When searching consider only points that map to the same bucket</p>
<p>RRT: steering to a given state</p>
<p>• This is an optimal control problem, but without a specified time constraint</p>
<p>• For omnidirectional systems we can connect states by a straight line.</p>
<p>• For more complicated systems you could use LQR.</p>
<p>• You could also use a large set of predefined controls, one of which could be able</p>
<p>to take the system close to the given state</p>
<p>RRT: steering to a given state</p>
<p>RRT: collision detection</p>
<p>• Main idea: bounding volume collision detection</p>
<p>Source: https://www.toptal.com/game/video-game-physics-part-ii-collision-detection-for-solid-objects</p>
<p>RRT example: moving a piano</p>
<p>RRT: properties of the planning algorithm</p>
<p>#1: The RRT will eventually cover the space, i.e.&nbsp;it is a space-filling tree</p>
<p>Source: Planning Algorithms, Lavalle</p>
<p>RRT: properties of the planning algorithm</p>
<p>#1: The RRT will eventually cover the space, i.e.&nbsp;it is a space-filling tree #2: The RRT will NOT compute the optimal path asymptotically</p>
<p>Source: Karaman, Frazzoli, 2010</p>
<p>This problem has been addressed in recent years by RRT<em>, BIT</em>, Fast-Marching Trees</p>
<p>RRT: properties of the planning algorithm</p>
<p>#1: The RRT will eventually cover the space, i.e.&nbsp;it is a space-filling tree #2: The RRT will NOT compute the optimal path asymptotically</p>
<p>#3: The RRT will exhibit “Voronoi bias,” i.e.&nbsp;new nodes will fall in free regions of Voronoi diagram (cells consist of points that are closest to a node)</p>
<p>Voronoi diagram</p>
<p>RRT: properties of the planning algorithm</p>
<p>#1: The RRT will eventually cover the space, i.e.&nbsp;it is a space-filling tree</p>
<p>#2: The RRT will NOT compute the optimal path asymptotically</p>
<p>#3: The RRT will exhibit “Voronoi bias,” i.e.&nbsp;new nodes will fall in free regions of Voronoi diagram</p>
<p>#4: The probability of RRT finding a path increases exponentially in the number of iterations</p>
<p>RRT: properties of the planning algorithm</p>
<p>#1: The RRT will eventually cover the space, i.e.&nbsp;it is a space-filling tree</p>
<p>#2: The RRT will NOT compute the optimal path asymptotically</p>
<p>#3: The RRT will exhibit “Voronoi bias,” i.e.&nbsp;new nodes will fall in free regions of Voronoi diagram</p>
<p>#4: The probability of RRT finding a path increases exponentially in the number of iterations</p>
<p>#5: The distribution of RRT’s nodes is the same as the distribution used in SampleFree()</p>
<p>RRT variants: bidirectional search</p>
<p>Probabilistic RoadMaps (PRMs)</p>
<p>• RRTs were good for single-query path planning • You need to re-plan from scratch for every query A → B</p>
<p>• PRM addresses this problem • It is good for multi-query path planning</p>
<p>PRM</p>
<p>PRM</p>
<p>PRM</p>
<p>PRM</p>
<p>Each node is connected to its neighbors (e.g.&nbsp;within a radius)</p>
<p>PRM</p>
<p>In the offline PRM construction phase we maintain a matrix D[i, j] which contains the total distance of the shortest path from node i to node j.</p>
<p>We can do this with an all pairs shortest paths algorithm and then incrementally update D as new nodes are added.</p>
<p>PRM</p>
<p>In the online PRM query phase we are given two endpoints (not vertices of the graph) and we want to find the shortest path between them, by making use of the matrix D[i, j] that was precomputed in the offline phase.</p>
<p>We can incorporate the endpoints in the graph and add 1 row and 1 column to D</p>
<p>PRM</p>
<p>To perform a query (A-&gt;B) we need to connect A and B to the PRM. We can do this by nearest neighbor search (kd-trees, hashing etc.)</p>
<p>PRM</p>
<p>Range search can be done efficiently using a kd-tree</p>
<p>To perform a query (A-&gt;B) we need to connect A and B to the PRM. We can do this by nearest neighbor search (kd-trees, hashing etc.)</p>
<p>Visibility Graph Path Planning</p>
<p>Visibility Graph Path Planning</p>
<p>Visibility Graph Path Planning</p>
<p>Visibility Graph Path Planning</p>
<p>Visibility Graph Path Planning</p>
<p>Visibility Graph Path Planning</p>
<p>Visibility graph</p>
<p>Can use graph search on visibility graph to find shortest path</p>
<p>Visibility Graph Path Planning</p>
<p>Potential problem: shortest path touches obstacle corners. Need to dilate obstacles.</p>
<p>Visibility Graph Path Planning</p>
<p>Path smoothing</p>
<p>• Plans obtained from any of these planners are not going to be smooth</p>
<p>• A plan is a sequence of states:</p>
<p>• We can get a smoother path by minimizing the</p>
<p>following cost function</p>
<p>• May need to stop smoothing when smooth path comes close to obstacles.</p>
<p>Stay close to the old path</p>
<p>Penalize squared length</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/csc477\.github\.io\/website_fall24");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Florian Shkurti</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions"><ul><li><a href="https://github.com/csc477/website_fall24/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This page is built with ❤️, <a href="https://quarto.org/">Quarto</a> and inspiration from <a href="https://sta210-s22.github.io/website/">STA210</a>.</p>
</div>
  </div>
</footer>




</body></html>